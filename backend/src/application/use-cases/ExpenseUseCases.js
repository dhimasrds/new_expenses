import { Expense } from '../../domain/entities/Expense.js'
import { 
  CreateExpenseDTO, 
  UpdateExpenseDTO, 
  ExpenseFilterDTO, 
  PaginationDTO,
  ExpenseResponseDTO,
  ExpenseListResponseDTO,
  ExpenseSummaryResponseDTO
} from '../dto/ExpenseDTO.js'

/**
 * Use case for creating a new expense
 */
export class CreateExpenseUseCase {
  constructor(expenseRepository, expenseService) {
    this.expenseRepository = expenseRepository
    this.expenseService = expenseService
  }

  async execute(createExpenseDTO) {
    // Create expense entity
    const expense = new Expense(
      null, // ID will be generated by repository
      createExpenseDTO.userId,
      createExpenseDTO.description,
      createExpenseDTO.amount,
      createExpenseDTO.category,
      createExpenseDTO.date
    )

    // Validate expense
    const validation = expense.validate()
    if (!validation.isValid) {
      throw new Error(`Validation failed: ${validation.errors.join(', ')}`)
    }

    // Save expense
    const savedExpense = await this.expenseRepository.save(expense)

    return ExpenseResponseDTO.fromExpense(savedExpense)
  }
}

/**
 * Use case for getting expenses with filters and pagination
 */
export class GetExpensesUseCase {
  constructor(expenseRepository) {
    this.expenseRepository = expenseRepository
  }

  async execute(userId, query) {
    const page = parseInt(query.page) || 1
    const limit = parseInt(query.limit) || 10
    const offset = (page - 1) * limit

    const { expenses, total } = await this.expenseRepository.findByUserId(
      userId,
      {
        category: query.category,
        dateFrom: query.dateFrom,
        dateTo: query.dateTo,
        search: query.search
      },
      {
        limit,
        offset
      }
    )

    return {
      data: ExpenseResponseDTO.fromExpenses(expenses),
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    }
  }
}

/**
 * Use case for getting a single expense by ID
 */
export class GetExpenseByIdUseCase {
  constructor(expenseRepository) {
    this.expenseRepository = expenseRepository
  }

  async execute(expenseId, userId) {
    const expense = await this.expenseRepository.findByIdAndUserId(expenseId, userId)
    
    if (!expense) {
      throw new Error('Expense not found')
    }

    return ExpenseResponseDTO.fromExpense(expense)
  }
}

/**
 * Use case for updating an expense
 */
export class UpdateExpenseUseCase {
  constructor(expenseRepository, expenseService) {
    this.expenseRepository = expenseRepository
    this.expenseService = expenseService
  }

  async execute(updateExpenseDTO) {
    // Find existing expense
    const existingExpense = await this.expenseRepository.findByIdAndUserId(
      updateExpenseDTO.id,
      updateExpenseDTO.userId
    )

    if (!existingExpense) {
      throw new Error('Expense not found')
    }

    // Check if user can update this expense
    if (!this.expenseService.canUpdateExpense(existingExpense, updateExpenseDTO.userId)) {
      throw new Error('Not authorized to update this expense')
    }

    // Update expense
    existingExpense.update({
      description: updateExpenseDTO.description,
      amount: updateExpenseDTO.amount,
      category: updateExpenseDTO.category,
      date: updateExpenseDTO.date
    })

    // Validate updated expense
    const validation = existingExpense.validate()
    if (!validation.isValid) {
      throw new Error(`Validation failed: ${validation.errors.join(', ')}`)
    }

    // Save updated expense
    const updatedExpense = await this.expenseRepository.update(existingExpense)

    return ExpenseResponseDTO.fromExpense(updatedExpense)
  }
}

/**
 * Use case for deleting an expense
 */
export class DeleteExpenseUseCase {
  constructor(expenseRepository, expenseService) {
    this.expenseRepository = expenseRepository
    this.expenseService = expenseService
  }

  async execute(expenseId, userId) {
    // Find existing expense
    const existingExpense = await this.expenseRepository.findByIdAndUserId(expenseId, userId)

    if (!existingExpense) {
      throw new Error('Expense not found')
    }

    // Check if user can delete this expense
    if (!this.expenseService.canDeleteExpense(existingExpense, userId)) {
      throw new Error('Not authorized to delete this expense')
    }

    // Delete expense
    const deleted = await this.expenseRepository.deleteByIdAndUserId(expenseId, userId)

    if (!deleted) {
      throw new Error('Failed to delete expense')
    }

    return { success: true, message: 'Expense deleted successfully' }
  }
}

/**
 * Use case for getting expense summary
 */
export class GetExpenseSummaryUseCase {
  constructor(expenseRepository, expenseService) {
    this.expenseRepository = expenseRepository
    this.expenseService = expenseService
  }

  async execute(filterDTO) {
    const summary = await this.expenseRepository.getSummaryByUserId(
      filterDTO.userId,
      {
        category: filterDTO.category,
        dateFrom: filterDTO.dateFrom,
        dateTo: filterDTO.dateTo
      }
    )

    return ExpenseSummaryResponseDTO.fromSummary(summary)
  }
}